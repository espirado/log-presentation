import {
  Kt,
  Yt,
  zt
} from "./chunk-56XCTST4.js";
import {
  bt
} from "./chunk-QM2AR5CL.js";
import "./chunk-PHLMXOST.js";
import "./chunk-EVVZP4ZQ.js";
import "./chunk-7WLFNJ6X.js";
import "./chunk-IZDBRU2T.js";
import {
  Ze
} from "./chunk-WUGNBG77.js";
import "./chunk-5CK3MYYT.js";
import "./chunk-NBSQHQBT.js";
import "./chunk-Y47YNRVZ.js";
import {
  F_,
  Jn,
  L,
  M0,
  Rn,
  Tt,
  ni,
  v0,
  zf
} from "./chunk-ZRK2H3ZA.js";
import "./chunk-YGAUDZUZ.js";

// node_modules/mermaid/dist/classDiagram-v2-20d1e04b.js
var S = (o) => Rn.sanitizeText(o, Jn());
var v = {
  dividerMargin: 10,
  padding: 5,
  textHeight: 10,
  curve: void 0
};
var P = function(o, e, p, n) {
  const t = Object.keys(o);
  L.info("keys:", t), L.info(o), t.forEach(function(s) {
    var y, d;
    const l = o[s], i = {
      shape: "rect",
      id: l.id,
      domId: l.domId,
      labelText: S(l.id),
      labelStyle: "",
      style: "fill: none; stroke: black",
      // TODO V10: Flowchart ? Keeping flowchart for backwards compatibility. Remove in next major release
      padding: ((y = Jn().flowchart) == null ? void 0 : y.padding) ?? ((d = Jn().class) == null ? void 0 : d.padding)
    };
    e.setNode(l.id, i), I(l.classes, e, p, n, l.id), L.info("setNode", i);
  });
};
var I = function(o, e, p, n, t) {
  const s = Object.keys(o);
  L.info("keys:", s), L.info(o), s.filter((l) => o[l].parent == t).forEach(function(l) {
    var u, m;
    const a = o[l], i = a.cssClasses.join(" "), y = M0(a.styles), d = a.label ?? a.id, f = 0, h = "class_box", b = {
      labelStyle: y.labelStyle,
      shape: h,
      labelText: S(d),
      classData: a,
      rx: f,
      ry: f,
      class: i,
      style: y.style,
      id: a.id,
      domId: a.domId,
      tooltip: n.db.getTooltip(a.id, t) || "",
      haveCallback: a.haveCallback,
      link: a.link,
      width: a.type === "group" ? 500 : void 0,
      type: a.type,
      // TODO V10: Flowchart ? Keeping flowchart for backwards compatibility. Remove in next major release
      padding: ((u = Jn().flowchart) == null ? void 0 : u.padding) ?? ((m = Jn().class) == null ? void 0 : m.padding)
    };
    e.setNode(a.id, b), t && e.setParent(a.id, t), L.info("setNode", b);
  });
};
var F = function(o, e, p, n) {
  L.info(o), o.forEach(function(t, s) {
    var m, g;
    const l = t, a = "", i = { labelStyle: "", style: "" }, y = l.text, d = 0, f = "note", h = {
      labelStyle: i.labelStyle,
      shape: f,
      labelText: S(y),
      noteData: l,
      rx: d,
      ry: d,
      class: a,
      style: i.style,
      id: l.id,
      domId: l.id,
      tooltip: "",
      type: "note",
      // TODO V10: Flowchart ? Keeping flowchart for backwards compatibility. Remove in next major release
      padding: ((m = Jn().flowchart) == null ? void 0 : m.padding) ?? ((g = Jn().class) == null ? void 0 : g.padding)
    };
    if (e.setNode(l.id, h), L.info("setNode", h), !l.class || !(l.class in n))
      return;
    const b = p + s, u = {
      id: `edgeNote${b}`,
      //Set relationship style and line type
      classes: "relation",
      pattern: "dotted",
      // Set link type for rendering
      arrowhead: "none",
      //Set edge extra labels
      startLabelRight: "",
      endLabelLeft: "",
      //Set relation arrow types
      arrowTypeStart: "none",
      arrowTypeEnd: "none",
      style: "fill:none",
      labelStyle: "",
      curve: v0(v.curve, zf)
    };
    e.setEdge(l.id, l.class, u, b);
  });
};
var H = function(o, e) {
  const p = Jn().flowchart;
  let n = 0;
  o.forEach(function(t) {
    var l;
    n++;
    const s = {
      //Set relationship style and line type
      classes: "relation",
      pattern: t.relation.lineType == 1 ? "dashed" : "solid",
      id: `id_${t.id1}_${t.id2}_${n}`,
      // Set link type for rendering
      arrowhead: t.type === "arrow_open" ? "none" : "normal",
      //Set edge extra labels
      startLabelRight: t.relationTitle1 === "none" ? "" : t.relationTitle1,
      endLabelLeft: t.relationTitle2 === "none" ? "" : t.relationTitle2,
      //Set relation arrow types
      arrowTypeStart: D(t.relation.type1),
      arrowTypeEnd: D(t.relation.type2),
      style: "fill:none",
      labelStyle: "",
      curve: v0(p == null ? void 0 : p.curve, zf)
    };
    if (L.info(s, t), t.style !== void 0) {
      const a = M0(t.style);
      s.style = a.style, s.labelStyle = a.labelStyle;
    }
    t.text = t.title, t.text === void 0 ? t.style !== void 0 && (s.arrowheadStyle = "fill: #333") : (s.arrowheadStyle = "fill: #333", s.labelpos = "c", ((l = Jn().flowchart) == null ? void 0 : l.htmlLabels) ?? Jn().htmlLabels ? (s.labelType = "html", s.label = '<span class="edgeLabel">' + t.text + "</span>") : (s.labelType = "text", s.label = t.text.replace(Rn.lineBreakRegex, `
`), t.style === void 0 && (s.style = s.style || "stroke: #333; stroke-width: 1.5px;fill:none"), s.labelStyle = s.labelStyle.replace("color:", "fill:"))), e.setEdge(t.id1, t.id2, s, n);
  });
};
var V = function(o) {
  v = {
    ...v,
    ...o
  };
};
var W = async function(o, e, p, n) {
  L.info("Drawing class - ", e);
  const t = Jn().flowchart ?? Jn().class, s = Jn().securityLevel;
  L.info("config:", t);
  const l = (t == null ? void 0 : t.nodeSpacing) ?? 50, a = (t == null ? void 0 : t.rankSpacing) ?? 50, i = new Ze({
    multigraph: true,
    compound: true
  }).setGraph({
    rankdir: n.db.getDirection(),
    nodesep: l,
    ranksep: a,
    marginx: 8,
    marginy: 8
  }).setDefaultEdgeLabel(function() {
    return {};
  }), y = n.db.getNamespaces(), d = n.db.getClasses(), f = n.db.getRelations(), h = n.db.getNotes();
  L.info(f), P(y, i, e, n), I(d, i, e, n), H(f, i), F(h, i, f.length + 1, d);
  let b;
  s === "sandbox" && (b = Tt("#i" + e));
  const u = s === "sandbox" ? Tt(b.nodes()[0].contentDocument.body) : Tt("body"), m = u.select(`[id="${e}"]`), g = u.select("#" + e + " g");
  if (await bt(
    g,
    i,
    ["aggregation", "extension", "composition", "dependency", "lollipop"],
    "classDiagram",
    e
  ), ni.insertTitle(m, "classTitleText", (t == null ? void 0 : t.titleTopMargin) ?? 5, n.db.getDiagramTitle()), F_(i, m, t == null ? void 0 : t.diagramPadding, t == null ? void 0 : t.useMaxWidth), !(t != null && t.htmlLabels)) {
    const T = s === "sandbox" ? b.nodes()[0].contentDocument : document, M = T.querySelectorAll('[id="' + e + '"] .edgeLabel .label');
    for (const w of M) {
      const L2 = w.getBBox(), x = T.createElementNS("http://www.w3.org/2000/svg", "rect");
      x.setAttribute("rx", 0), x.setAttribute("ry", 0), x.setAttribute("width", L2.width), x.setAttribute("height", L2.height), w.insertBefore(x, w.firstChild);
    }
  }
};
function D(o) {
  let e;
  switch (o) {
    case 0:
      e = "aggregation";
      break;
    case 1:
      e = "extension";
      break;
    case 2:
      e = "composition";
      break;
    case 3:
      e = "dependency";
      break;
    case 4:
      e = "lollipop";
      break;
    default:
      e = "none";
  }
  return e;
}
var J = {
  setConf: V,
  draw: W
};
var ot = {
  parser: zt,
  db: Kt,
  renderer: J,
  styles: Yt,
  init: (o) => {
    o.class || (o.class = {}), o.class.arrowMarkerAbsolute = o.arrowMarkerAbsolute, Kt.clear();
  }
};
export {
  ot as diagram
};
//# sourceMappingURL=classDiagram-v2-20d1e04b-KOAGUCTC.js.map
